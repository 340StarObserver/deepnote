# 需求描述 #


--------------------------------------------------


## 之前的demo版的功能 ##

账户模块  
> 用户登陆，注册，注销  

笔记搜索模块  
> 通过若干关键词进行搜索  
> 通过书名作者名进行搜索  
> 通过id进行精确搜索  

笔记管理模块  
> 加载我的笔记分类和每个分类下的笔记  
> 新增笔记分类  
> 笔记发布  
> 笔记的点赞，收藏，评论  
> 我的笔记收藏  
> 评论提醒  

笔记推送模块  
> 加载热门的笔记推送（这是公共推送，个性化定制推送将计划在正式版中增加）  


--------------------------------------------------


## v1.0需求设计 ##


客户端写笔记模块  


1，客户端笔记草稿本  

> 1-1. 草稿笔记类的封装  
>> 草稿笔记的属性 ： 草稿id，标题，[是否私有]，分类名，[原文出处]，[原文链接]，[引用的原文]，感受，标签们  
>> 其中 ： 草稿id是唯一的，可用时间戳来表示  
>> 其中 ： 是否私有，默认是公开的  
>> 其中 ： 原文出处，原文链接，引用原文默认情况下是null  
>> 其中 ： 标签们默认情况下是空的字符串数组  

> 1-2. 实现一个单例的本地数据库管理器对象  
>> 封装了数据库的名称，各表的表名，数据库版本  
>> 每当获取连接的时候，检测库和各表是否已创建，若无则自动创建  
>> 只创建一次连接，重复利用，用完并不断开连接  
>> 能够接受草稿笔记对象或其他需要持久化的对象，并持久化（有则更新无则插入）到对应的数据表中  
>> 当不同的线程（包括主线程）都去使用该管理器对象的时候，需要在使用该对象的地方加入同步控制  

> 1-3. 草稿笔记的持久化  
>> 通过使用单例的本地数据库管理器对象来持久化到本地数据库  
>> 每一个草稿笔记都对应本地数据库中的一条记录  
>> 其中 ： 标签们存储的时候用逗号拼接的字符串，形如 "标签1,标签2,标签3"  

> 1-4. 草稿笔记列表类的封装  
>> 静态单例对象  
>> 内部是一个数组，每个元素为（草稿id，标题，分类名）表示一篇草稿笔记的头信息  
>> 使用单例的本地数据库管理器对象，从本地数据库读取草稿们的头信息，返回一个草稿笔记列表单例对象  
>> 在启动App的时候，不管有没有登陆，都生成这个单例对象  

> 1-5. 查看草稿笔记列表  
>> 不查本地数据库  
>> 直接使用内存中的草稿笔记列表的单例对象来进行显示  

> 1-6. 进入编辑某一篇草稿笔记  
>> 过程如下 :  
>> 通过该篇草稿的草稿id，查询本地数据库，返回草稿笔记的全部属性  
>> 显示除了草稿id之外的所有属性  
>> 显示出来的各属性是可以被编辑的  

> 1-7. 写笔记界面上（和草稿笔记的编辑界面是同一个界面），有按钮进行手动保存草稿 :  
>> 既要更新内存中的草稿笔记列表对象  
>> 也要更新本地数据库中对应的那一条草稿记录  


2，手动写笔记  

> 2-1. 需要填写 ： 标题，[是否私有]，分类名，[原文出处]，[原文链接]，[引用的原文]，感受，标签们  

> 2-2. 呈现方式优雅  

> 2-3. 用户写笔记的时候，是不一定非要登陆的  


3，一键链接生成笔记模板  

> 3-1. 复制一段引用的原文，自动转到App生成笔记模板  

> 3-2. 若用户没有填链接 :  
>> 则使用引用的原文，客户端暗地里去请求百度的高级搜索，挑一个"合适的"（随机选择一个）作为链接  


4，拍照识别生成笔记模板  

> 4-1. 使用Cloud-OCR  

> 4-2. 原文链接自动填null  


--------------------------------------------------


## v1.1需求设计 ##

账户模块  


1，用户注册  

> 1-1. 网络配置类的封装  
>> 静态单例对象  
>> 不需要持久化到磁盘或本地数据库（该对象不大，启动App后位于内存就行）  
>> 包含属性 ：  
>> a. server列表，其中每一个元素都是字符串，形如 "ip:port"  
>> b. 本次使用App所选用的server的下标（开始为-1，之后请求的时候检测若为-1则随机挑一个，不为-1则继续用原来的）  
>> c. session_id（开始为null，登陆成功后要设置它）  
>> d. token  
>>> 这个token是重要操作的令牌，开始为-1  
>>> 登陆成功后服务端会返回给你这个值，它是一个随机数，之后进行重要操作需要在请求中带上它  
>>> 且它是一次一密的，用完后服务端会返回给你一个新的token，你需要更新它  
>>> 若服务端返回token验证错误，则你需要重新输入密码登陆  

> 1-2. 需要（用户名，密码，头像）  
>> 若使用用户自己上传的头像，则需要提交前在客户端等比例缩小到一定尺寸，并且提供缩小后的预览功能  
>> 若使用系统默认头像，则不需要缩小（因为默认头像本身足够小）  
>> 一次性提交所有数据  
>> 密码提交前要转化为md5-32位的密文  
>> 头像是通过把头像的二进制数据转化为base64编码，再像提交普通字符串参数一样提交  

> 1-3. 主线程要等待这个注册请求的线程  

> 1-4. 注册成功后，先提示注册成功，然后倒计时几秒钟，再自动登陆  

> 1-5. 采用邀请码的方式，且注册成功后用户自动拥有邀请码（也就拥有了邀请别人的权利）  


2，用户登陆  

> 2-1. 个人基本信息类的封装  
>> 静态单例对象  
>> 该类包含　：　用户名，加密密码，头像（图片二进制数据的base64编码）  
>> 通过使用单例的数据库管理器对象，持久化到本地数据库  
>> 通过使用单例的数据库管理器对象，从本地数据库读取数据并创建个人基本信息对象并返回  

> 2-2. 第一次登陆，发送请求之前，就要创建个人基本信息的单例对象（用以在界面跳转之间暂存数据）  

> 2-3. 主线程要等待这个登陆请求的线程  

> 2-4. 第一次登陆后 :  
>> 根据服务端传来的数据，更新内存中的个人基本信息对象中的头像  
>> 更新内存中的网络配置类对象中的session_id和token  
>> 把个人信息持久化到本地数据库  

> 2-5. 之后登陆，都是先从本地数据库读取数据，创建单例的个人基本信息对象，再自动检测网络是否通畅 :  
>> 若网络通畅，则利用个人基本信息对象中的属性进行自动登陆  
>> 若网络不通畅，则不发送登陆请求，并进入个人主页显示本地已有的笔记，并提示网络不通  

> 2-6. 用户在登陆后，可以进行删除本地的个人数据的操作，那样的话，本地的所有个人数据（包括个人基本数据,笔记草稿数据，笔记数据）都会被删除，且下次需要手动输入账号密码  

> 2-7. 在等待登陆结果的时候，显示该用户的头像和用户名，不要什么都没有干等着  


3，用户注销  

> 手动注销的时候，提示用户是否删除本地个人数据  


--------------------------------------------------


## v1.2需求设计 ##

笔记管理模块  


1，已发布笔记类（不同于草稿笔记类）的封装  

> 包含的属性 ： 笔记id，标题，作者用户名，发布时间，是否私有，所属分类名，引用文章的出处，引用文章的链接，引用文段，个人感悟，标签列表，认同数，反对数，评论数，收藏数，阅读数，评论对象列表  
>> 评论类的封装（评论编号，父评论编号，评论时间，评论者用户名，评论内容）  

> 能够持久化 :  
>> 通过使用单例的数据库管理器对象来持久化到本地数据库  
>> 本地数据库中，已发布笔记表和草稿笔记表是不同的表  

> 能够恢复 :  
>> 通过使用单例的数据库管理器对象，通过笔记id来查询本地数据库，使用查到的数据构造出一个已发布笔记对象，并返回  


2，已发布笔记表类的封装  

> 静态单例对象  

> 该对象相当于是已发布笔记的列表的简略信息  

> 内部是一个数组，每个元素是一篇已发布笔记的简略信息（笔记id，标题，发布时间，是否私有，个人感悟的一部分，评论数）  

> 首次登陆成功后，发送加载个人笔记的请求（主线程等待该请求线程），播放一个加载动画，收到响应数据后 :  
>> 先构造出这个单例的已发布笔记表对象  
>> 然后暗中开一个线程，负责把所有已发布笔记的详细数据，一次性批量更新到本地数据库  
>> 启动这个线程后，立即停止动画，并转入个人主页  


3，查看自己某分类下的笔记列表  

> 不需要登陆  

> 不发送请求，直接使用内存中的已发布笔记表类的单例对象中的数据  

> 对于每篇笔记，显示（标题，发布时间，是否私有，个人感悟的一部分，评论数）  

> 按照发布时间降序排列  


4，查看自己某分类下的某一篇笔记的具体内容  

> 不需要登陆  

> 不发送请求，使用单例的本地数据库管理器对象，传入笔记id来查询本地数据库  

> 显示（标题，发布时间，是否私有，所属分类名，引用文章的出处，引用文章的链接，引用文段，个人感悟，标签列表，认同数，反对数，收藏数，阅读数，全部评论）  


5，同步自己某分类下的某一篇笔记  

> 在查看自己某分类下的某一篇笔记的具体内容的那个界面，有一个按钮，能够同步获取该篇笔记最新的（认同数，反对数，收藏数，阅读数，全部评论）  

> 点击同步后 ：  
>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>> 若没有登陆，则在当前界面弹出一个登陆框，登陆成功后登陆框消失，并自动发送同步请求  

> 主线程要等待这个同步请求的线程  

> 该请求需要带上token  

> 接收到服务端的响应后 ：  
> 首先需要更新界面上的显示，然后暗中开启一个线程，它负责 :  
>> 更新内存中的单例的已发布笔记表对象  
>> 更新本地数据库中的对应记录  


6，笔记的发布  

> 点击提交后 :  
>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>> 若没有登陆，则在当前界面上弹出一个登陆框，登陆成功后该登陆框消失，并自动发起网络请求  

> 主线程要等待这个发布请求的线程  

> 该请求需要带上token  

> 收到服务端的响应后，若发布成功 :  
>> 更新内存中的单例已发布笔记表对象  
>> 更新内存中的单例草稿笔记表对象  
>> 开启一个线程，负责把该篇笔记插入到本地数据库的已发布笔记table中，并删除本地数据库中的草稿笔记table中的对应记录  
>> 开启上述线程后，立即转入个人主页  


7，笔记的更新  

> 在查看自己的某篇笔记的界面（查看自己的笔记不需要登陆，因为本地数据库里就有），有个编辑按钮  

> 可以修改 ： 笔记标题，是否私有，分类名，个人感悟，标签们  

> 点击保存后 :  
>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>> 若没有登陆，则在当前界面上弹出一个登陆框，登陆成功后该登陆框消失，并自动发起网络请求  

> 主线程要等待这个更新请求的线程  

> 该请求需要带上token  

> 收到服务端的响应后，若保存成功 :  
>> 更新当前界面上的显示  
>> 开一个线程，负责更新内存中的已发布笔记表的单例对象，并更新本地数据库中已发布笔记table中对应的记录  


8，笔记的删除  

> 在查看自己的某篇笔记的界面（查看自己的笔记不需要登陆，因为本地数据库里就有），有个删除按钮  

> 点击删除后 :  
>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>> 若没有登陆，则在当前界面上弹出一个登陆框，登陆成功后该登陆框消失，并自动发起网络请求  

> 主线程要等待这个删除请求的线程  

> 该请求需要带上token  

> 收到服务端的响应后，若删除成功 :  
>> 开一个线程，负责更新内存中的已发布笔记表的单例对象，并删除本地数据库中已发布笔记table中对应的记录  
>> 启动这个线程后，立即转到个人主页  


9，笔记的收藏  

> 在精确搜索某篇笔记后，展示那篇笔记具体内容的界面上，有用来收藏的按钮  

> 点击收藏后 :  
>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>> 若没有登陆，则在当前界面上弹出一个登陆框，登陆成功后该登陆框消失，并自动发起网络请求  

> 主线程要等待这个收藏请求的线程  

> 收到服务端的响应后，若删除成功 :  
>> 通过数据库管理器对象，将这篇读书笔记的（笔记id，标题，感受的一部分）插入到本地数据库的笔记收藏表中  


10，查看我收藏的笔记列表  

> 不需要登陆  

> 不发送请求，使用单例的本地数据库管理器对象，查询本地数据库中的笔记收藏表  

> 显示每篇收藏的笔记的标题和感受的一部分  


11，笔记的点赞，反对，评论  

> 在精确搜索某篇笔记后，展示那篇笔记具体内容的界面上，有用来点赞，反对，评论的按钮  

> 点击点赞 or 反对 or 评论（事先输入内容）后 :  
>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>> 若没有登陆，则在当前界面上弹出一个登陆框，登陆成功后该登陆框消失，并自动发起网络请求  

> 发起请求后（即启动该请求所需的线程后） :  
>> 立即更新界面上的显示  
>> 不用等待该线程  


12，最新评论提醒池的封装  

> 它实际上是本地数据库中的一张表，称为评论表  

> 每条记录包含（主键id，评论者，评论时间，相关笔记的id，评论内容）  

> 用户查看与我相关的评论，就取出最后的5条记录，再滚一次就会取出上5条记录（反序分页）  


13，获取最新评论  

> 分为 "手动获取最新评论" 和 "顺带获取最新评论" 两种方式  

> 手动获取 :  

>> 提供按钮，能够让用户手动去发起请求获取最新评论  

>> 点击按钮后 :  
>>> 自动检测是否已登陆（通过查看单例的网络配置对象中的session_id）  
>>> 若没有登陆，则在当前界面上弹出一个登陆框，登陆成功后该登陆框消失，并自动发起网络请求  

>> 主线程需要等待这个手动获取最新评论请求的线程  

>> 获取服务端的响应后 :  
>>> 通过使用单例的本地数据库管理器对象，将最新的评论一次性批量插入到本地数据库的评论表中  
>>> 从本地数据库中查询出最近的5条，并展示  

> 顺带获取 :  

>> 意思是说，在进行某些其他请求的时候，服务端会顺带地把和用户相关的最新的评论返回  

>> 客户端在进行某些其他请求的时候，每收到顺带返回的评论 :  
>>> 要把服务端顺带返回的评论一次性批量插入到本地数据库的评论表中  
>>> 要点亮某个图标，好让用户知道有最新的评论了  


--------------------------------------------------


## v2.0需求设计 ##

笔记搜索模块  


1，根据若干关键词搜索读书笔记  

> 对于每一篇足够匹配的读书笔记，需要返回它的（笔记id，标题，标签们，认同数，反对数，评论数，收藏数，阅读数，感受的一部分，热度）  

> 搜索结果根据匹配程度和热度，降序排列  

> 第一个关键词的权重最大  

> 支持分页查询  

> 不需要登陆  

> 用户输入多个关键词时的体验要好  

> 搜索结果优雅呈现  

> 没有查到的时候，也有一个比较优雅的反馈  

> 搜索速度必须优化，但目前对具体数字指标还没底  


2，根据书名来搜索读书笔记  

> 对于每一篇足够匹配的读书笔记，需要返回它的（笔记id，标题，标签们，认同数，反对数，评论数，收藏数，阅读数，感受的一部分，热度）  

> 搜索结果根据匹配程度和热度，降序排列  

> 支持分页查询  

> 不需要登陆  

> 可以手动搜索，用户输入书名的时候体验要好  

> 可以自动搜索，即用户在看某一篇笔记的详细信息的那个页面上，可以点个按钮自动以该篇笔记的书名来搜索  

> 搜索结果优雅呈现  

> 没有查到的时候，也有一个比较优雅的反馈  

> 搜索速度必须优化，但目前对具体数字指标还没底  


3，根据读书笔记的id来搜索读书笔记  

> 返回这篇读书笔记的（笔记id，标题，作者，发布时间，引用文章的出处，引用文章的链接，引用文段，感受，标签们，认同数，反对数，评论数，收藏数，阅读数，全部评论内容）  

> 阅读数自动加一  

> 不需要登陆  

> 笔记内容优雅呈现  

> 没有查到的时候，也有一个比较优雅的反馈  


--------------------------------------------------


## v3.0需求设计 ##

笔记推送模块  

1，笔记的公共推送  

> 公共推送是分几个大类的  

> 进入某一类，看到的是笔记列表，对于每篇笔记 :  
>> 获取的是（笔记id，标题，个人感受的一部分，阅读数）  
>> 显示的是（标题，个人感受的一部分，阅读数）  

> 公共推送每天更新一次，且推送的是一周内的各分类下的热门笔记  

> 推送需要能够有效过滤掉那种明显是水军刷出来的  

> 获取公共推送不需要登陆  


2，笔记的个性化推送  

